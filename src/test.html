<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Video Chat</title>
    <style>
      #videos {
        display: flex;
        justify-content: center;
      }
      video {
        width: 320px;
        height: 240px;
        margin: 10px;
        border: 1px solid black;
      }
      #chatbox {
        width: 320px;
        margin: 10px;
        padding: 10px;
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <div id="videos">
      <video id="localVideo" autoplay muted></video>
    </div>
    <div id="userCount" style="margin: 10px; font-weight: bold;">참여자 수: 1</div>
    <div id="chatbox">
      <textarea id="chatArea" rows="10" cols="30" readonly></textarea><br />
      <input type="text" id="messageInput" /><button onclick="sendMessage()">Send</button>
    </div>

    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script>
      const localVideo = document.getElementById('localVideo');
      const chatArea = document.getElementById('chatArea');
      const messageInput = document.getElementById('messageInput');
      const room = 'testRoom';
      const socket = io('http://13.238.227.125:3000', {
        transports: ['websocket'],
        upgrade: false,
      });

      let localStream;
      let peerConnections = {};
      const config = {
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
      };

      // 여러 명의 remote video를 관리하기 위한 객체
      const remoteVideos = {};

      // 비디오 엘리먼트 동적 추가 함수
      function addRemoteVideo(userId) {
        if (remoteVideos[userId]) return;
        const video = document.createElement('video');
        video.id = `remoteVideo_${userId}`;
        video.autoplay = true;
        video.playsInline = true;
        video.width = 320;
        video.height = 240;
        document.getElementById('videos').appendChild(video);
        remoteVideos[userId] = video;
      }

      // 비디오 엘리먼트 동적 삭제 함수
      function removeRemoteVideo(userId) {
        const video = remoteVideos[userId];
        if (video) {
          video.parentNode.removeChild(video);
          delete remoteVideos[userId];
        }
      }

      // 방 입장
      navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then((stream) => {
          localStream = stream;
          localVideo.srcObject = stream;
          socket.emit('joinRoom', { 
            room,
            clientType: 'web_client',
            deviceType: 'browser',
            userId: socket.id
          });
        })
        .catch((error) => {
          console.error('Error accessing media devices.', error);
        });

      // 서버에서 현재 방의 사용자 목록을 전달
      socket.on('usersInRoom', (data) => {
        console.log('방 사용자 목록 수신:', data);
        
        let users = [];
        if (Array.isArray(data)) {
          users = data;
        } else if (data.users) {
          users = data.users;
        }
        
        // 클라이언트 사용자 수만 카운트 (분석 서버 제외)
        let clientCount = 0;
        users.forEach((user) => {
          let clientType = 'unknown';
          if (typeof user === 'object' && user.clientType) {
            clientType = user.clientType;
          } else if (typeof user === 'string' && !user.includes('analysis')) {
            clientType = 'web_client';
          }
          
          if (clientType !== 'analysis_server' && clientType !== 'analysis') {
            clientCount++;
          }
        });
        
        document.getElementById('userCount').textContent = `참여자 수: ${clientCount}`;
        
        users.forEach((user) => {
          let userId, clientType;
          if (typeof user === 'object') {
            userId = user.id || user.userId || user.toString();
            clientType = user.clientType || 'unknown';
          } else {
            userId = user.toString();
            clientType = userId.includes('analysis') ? 'analysis_server' : 'web_client';
          }
          
          // 다른 웹/Flutter 클라이언트와만 P2P 연결 (분석 서버 제외)
          if (userId !== socket.id && 
              !peerConnections[userId] && 
              clientType !== 'analysis_server' && 
              clientType !== 'analysis') {
            console.log(`클라이언트와 P2P 연결 생성: ${userId} (type: ${clientType})`);
            createPeerConnection(userId);
            localStream.getTracks().forEach((track) => {
              peerConnections[userId].addTrack(track, localStream);
            });
            peerConnections[userId].createOffer()
              .then((offer) => peerConnections[userId].setLocalDescription(offer))
              .then(() => {
                socket.emit('offer', { 
                  to: userId, 
                  from: socket.id,
                  fromType: 'web_client',
                  sdp: peerConnections[userId].localDescription 
                });
              });
          }
        });
      });

      // offer/answer/ice-candidate signaling
      socket.on('offer', (data) => {
        const { from, fromType, sdp } = data;
        console.log(`Offer 수신 from: ${from} (type: ${fromType})`);
        
        // 분석 서버로부터의 Offer만 수락, 다른 클라이언트는 자체 생성
        if (fromType !== 'analysis_server' && fromType !== 'analysis' && !from.includes('analysis')) {
          console.log(`Offer 무시 - 다른 클라이언트: ${from} (type: ${fromType})`);
          return;
        }
        
        if (!peerConnections[from]) {
          createPeerConnection(from);
        }
        peerConnections[from].setRemoteDescription(new RTCSessionDescription(sdp))
          .then(() => {
            localStream.getTracks().forEach((track) => {
              peerConnections[from].addTrack(track, localStream);
            });
            return peerConnections[from].createAnswer();
          })
          .then((answer) => peerConnections[from].setLocalDescription(answer))
          .then(() => {
            socket.emit('answer', { 
              to: from, 
              from: socket.id,
              fromType: 'web_client',
              sdp: peerConnections[from].localDescription 
            });
          });
      });

      socket.on('answer', (data) => {
        const { from, sdp } = data;
        if (peerConnections[from]) {
          peerConnections[from].setRemoteDescription(new RTCSessionDescription(sdp));
        }
      });

      socket.on('ice-candidate', (data) => {
        const { from, candidate } = data;
        if (peerConnections[from]) {
          peerConnections[from].addIceCandidate(new RTCIceCandidate(candidate));
        }
      });

      // 피어 연결 생성
      function createPeerConnection(userId) {
        if (peerConnections[userId]) {
          peerConnections[userId].close();
          delete peerConnections[userId];
          removeRemoteVideo(userId);
        }
        const pc = new RTCPeerConnection(config);
        peerConnections[userId] = pc;
        addRemoteVideo(userId);
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit('ice-candidate', { to: userId, candidate: event.candidate });
          }
        };
        pc.ontrack = (event) => {
          remoteVideos[userId].srcObject = event.streams[0];
        };
      }

      // 사용자 퇴장 시 비디오 삭제
      socket.on('userDisconnected', (userId) => {
        if (peerConnections[userId]) {
          peerConnections[userId].close();
          delete peerConnections[userId];
        }
        removeRemoteVideo(userId);
      });

      function sendMessage() {
        const message = messageInput.value;
        chatArea.value += `Me: ${message}\n`;
        messageInput.value = '';
      }
    </script>
  </body>
</html>
